<!DOCTYPE html>
	<html lang="pl" dir="ltr" class="no-js">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<script>
			(function(H,c){H[c]=H[c].replace(/\bno-js\b/,'')+' js'})(document.documentElement,'className');
			</script>
			<title>Wypieść swój JS</title>
			<meta name="description" content="Kilka porad, aby Twój kod JS był jeszcze lepszy niż obecnie!">
			<meta property="og:title" content="Wypieść swój JS">
			<meta property="og:description" content="Kilka porad, aby Twój kod JS był jeszcze lepszy niż obecnie!">
			<meta property="og:type" content="article">
			<meta property="article:author" content="Comandeer">

			<meta property="og:url" content="https://tutorials.comandeer.pl/js-beauty.html">
			<meta property="og:image" content="https://tutorials.comandeer.pl/images/comandeer.jpg">
			<meta property="og:image:width" content="200">
			<meta property="og:image:height" content="200">


			<!--[if lt IE 9]>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
			<![endif]-->
			<link rel="stylesheet" href="/css/main.css">
		</head>
		<body>
			<nav class="navbar navbar-inverse navbar-fixed-top" aria-label="Nawigacja po witrynie">
				<div class="container-fluid">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#site-menu" aria-expanded="false">
							<span class="sr-only">Włącz/wyłącz menu</span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
						<a href="/" class="navbar-brand" title="« Powrót do spisu tutorialów">Tutorials</a>
					</div>

					<div class="collapse navbar-collapse" id="site-menu">
						<ul class="nav navbar-nav"><li><a href="polityka-prywatnosci.html">Polityka prywatności</a></li></ul>
					</div>
				</div>
			</nav>

			<main class="container-fluid">
				<div class="row">
					<div class="col-md-8 col-md-offset-4 header header_main">
						<h1 id="start" class="header__heading">Wypieść swój JS</h1>

						<a class="header__link" href="js-beauty.pdf" title="Wersja PDF"><span class="glyphicon glyphicon-book" aria-hidden="true"></span><span class="sr-only">Wersja <abbr title="Portable Document Format" lang="en">PDF</abbr></span></a>
					</div>
				</div>
				<div class="row">
					<nav class="sidebar col-md-4 well" aria-labelledby="toc-heading">
			<h2 class="sidebar-header" id="toc-heading">Spis treści</h2>
				<div class="sidebar-inner">
					<ul>
					<li><a href="#start">Wypieść swój JS</a><ul><li><a href="#parser">Inteligentny parser</a></li><li><a href="#krotszy-zapis">Krótszy zapis</a></li><li><a href="#strict">Strict mode</a></li><li><a href="#literaly">Literały</a></li><li><a href="#setTimeout">setTimeout</a></li><li><a href="#petle">Pętle i obiekty</a></li><li><a href="#namespaces">Funkcje natychmiastowego wywołania i przestrzenie nazw</a></li><li><a href="#feature-detection">Feature detection</a></li><li><a href="#delegation">Event delegation</a></li></ul></li>
					</ul>
				</div>
			</nav>

					<div class="content col-md-8 col-md-offset-0">
						<p></p>

<div class="alert alert-danger">
<p>Ten tutorial jest już niestety dość przestarzały i opisuje starszą wersję standardu JS (ECMAScript 5) a także niektóre praktyki, których obecnie nawet ja nie uznaję już za najlepsze. Dlatego lepiej potraktuj go wyłącznie jako ciekawostkę historyczną… i poczekaj aż napiszę o JS coś równie sensownego.</p>
</div>
<h2 id="parser">Inteligentny parser</h2>
<p>JS to język, który pozwala chyba na największą dowolność w składni ze wszystkich języków programowania. Ba, jego parser jest tak sprawny, że sam sobie wstawia średniki w miejscach, w których być powinny.</p>
<pre><code class="language-javascript">return
{};
</code></pre>
<p>Ten krótki kod – mimo że na pierwszy, a nawet drugi rzut oka wydaje się poprawny – rzuci nam ładny błąd na konsolę. Czemu? Bo parser widzi go tak:</p>
<pre><code class="language-javascript">return; //bo niedbały programista zapomniał go tu dać
{}; //o, a co tu robi definicja obiektu?
</code></pre>
<p>Przez to małe głupstwo kiedyś zraziłem się do JSON i za wszelką cenę próbowałem go omijać. Dlatego na sam początek porad ot, taki mały kwiatek z własnego doświadczenia.</p>
<h2 id="krotszy-zapis">Krótszy zapis</h2>
<pre><code class="language-javascript">var width = 0;
var height = 0;
var img = null;
var elem = null;
</code></pre>
<p>vs.</p>
<pre><code class="language-javascript">var width = 0
,height = 0
,img = null
,elem = null;
</code></pre>
<p>IMO czytelniej. Gdyby ktoś pytał czemu przecinek jest przerzucony na początek nowej linii, a nie zostawiony na końcu poprzedniej: spróbuj pousuwać parę zmiennych z listy. Jeśli przecinek jest na końcu linijki, musisz usunąć interesującą Cię zmienną, a następnie przecinek. Tak usuwasz jedno i drugie za jednym zamachem i na pewno nie zostawisz przecinka przez nieuwagę.</p>
<div class="alert alert-info">
<p>Od kiedy ten tutorial powstał, jednak powróciłem do &quot;normalnego&quot; sposobu zapisu przecinków. Mój styl można podejrzeć <a href="https://github.com/Comandeer" rel="noreferrer noopener" class="alert-link">na moim GitHubie</a>, a zwłaszcza <a href="https://github.com/BEMQuery/bemquery-package-boilerplate" rel="noreferrer noopener" class="alert-link">w projekcie BEMQuery</a>.</p>
</div>
<h2 id="strict">Strict mode</h2>
<p>To małe cudeńko bardzo ułatwia życie, utrudniając je. Włączenie tzw. &quot;strict mode&quot; (tryb ścisły jak ktoś polski lubi) usuwa najbardziej bugowate części JS (np. <code>with</code> czy też ciut naprawia stringi w <code>setTimeout</code>). Co więcej, nie pozwala nam tworzyć nieświadomie zmiennych globalnych, np tak:</p>
<pre><code class="language-javascript">for(i = 0; i&lt;tab.length; i++)
</code></pre>
<p>W trybie ścisłym każda zmienna musi być zadeklarowana przed użyciem</p>
<pre><code class="language-javascript">for(var i = 0; i &lt; tab.length; i++)
</code></pre>
<p>A jak włączyć naszego małego przyjaciela? Prosto</p>
<pre><code class="language-javascript">&quot;use strict&quot;; //na samym początku skryptu żeby działał wszędzie
function a()
{
	&quot;use strict&quot;; //lub w funkcji, aby działał tylko w niej
}
</code></pre>
<p>Od razu uprzedzam, że jeśli nigdy nie zwracałeś uwagi na jakość swojego JS, to po włączeniu strict mode skrypty Ci się wykrzaczą. Ale przystosowanie ich do strict mode wcale nie jest trudne, a w przyszłości na pewno przyniesie korzyści (bo np. ociupinkę zmieni się składnia JS).</p>
<h2 id="literaly">Literały</h2>
<p>Spójrzmy na ten kod:</p>
<pre><code class="language-javascript">var a = new Array(1, 2, 3)
,b = new Object();

b.a = 1;
b.b = 2;

for(var i = 0; i&lt;a.length; i++)
	console.log(a[i]);

for(var x in b)
	console.log(b[x]);
</code></pre>
<p>Wydaje się zupełnie poprawny, prawda? Owszem, może i jest poprawny, ale nie bezpieczny!</p>
<pre><code class="language-javascript">Array = function() {return '';};
Object = Array;

var a = new Array(1,2,3)
,b = new Object();

b.a = 1;
b.b = 2;

for(var i = 0; i&lt;a.length; i++)
	console.log(a[i]);

for(var x in b)
	console.log(b[x]);
</code></pre>
<p>I mamy krzak, nawet w strict mode! Bezpieczniej użyć literałów:</p>
<pre><code class="language-javascript">Array = function() {return '';};
Object = Array;

var a = [1,2,3]
,b = {a:1, b:2};

for(var i = 0; i &lt; a.length; i++)
	console.log(a[i]);

for(var x in b)
	console.log(b[x]);
</code></pre>
<p>Tych wykrzaczyć się nie da ;)</p>
<h2 id="setTimeout">setTimeout</h2>
<p>Nie przekazuj nazwy funkcji jako stringa!</p>
<pre><code class="language-javascript">setTimeout(&quot;funkcja()&quot;, 1000); //don't do this!
</code></pre>
<p>Tym samym wywołujesz sobie <code>eval</code>, a jak każdy wie – <code>eval</code> jest [s]złe[/s] niepotrzebnie wykorzystywane, co jedynie obniża wydajność! Przekaż uchwyt do funkcji:</p>
<pre><code class="language-javascript">setTimeout(funkcja, 1000);
</code></pre>
<p>A jak już musisz parametry przekazać:</p>
<pre><code class="language-javascript">setTimeout(function(){funkcja(1, 2);}, 1000);
//lub
setTimeout(funkcja, 1000, 1, 2);
</code></pre>
<h2 id="petle">Pętle i obiekty</h2>
<p>Masz obiekt i musisz po nim poiterować? Zapewne robisz coś takiego:</p>
<pre><code class="language-javascript">var o = {
	a: 1
	,b: 2
	,c: 3
};

for(var x in o)
{
	console.log(o[x]);
}
</code></pre>
<p>Zgadłem? No to źle robisz:</p>
<pre><code class="language-javascript">Object.prototype.oops = 'BUGAHA!';

var o = {
	a: 1
	,b: 2
	,c: 3
};

for(var x in o)
{
	console.log(o[x]);
}
</code></pre>
<p>Powyższy kod wyświetli nam także 'BUGAHA!' (bo <code>for..in</code> iteruje także po wszystkich nienatywnych rozszerzeniach prototypu <code>Object</code>). Nie tego chcemy, prawda? A wystarczy dodać jedną linijkę:</p>
<pre><code class="language-javascript">Object.prototype.oops = 'BUGAHA!';

var o = {
	a: 1
	,b: 2
	,c: 3
};

for(var x in o)
{
	if(o.hasOwnProperty(x))
		console.log(o[x]);
}
</code></pre>
<p>I już. Metoda <code>hasOwnProperty</code> sprawdza czy wartość podana jako x na pewno jest częścią naszego obiektu i czy nie pochodzi z prototypu.</p>
<p>Jest też inny sposób, aby zupełnie ominąć jakiekolwiek prototypy i nie martwić się o nie:</p>
<pre><code class="language-javascript">Object.prototype.oops = 'BUGAHA!';

var o = Object.create(null);
o.a = 1;
o.b = 2;
o.c = 3;

for(var x in o)
{
	console.log(o[x]);
}
</code></pre>
<p><code>Object.create</code> tworzy nam obiekt z prototypu podanego jako pierwszy parametr, tak więc tworzymy obiekt z pustym prototypem (domyślnie jest to <code>Object.prototype</code>). W starszych przeglądarkach ten sposób nie działa.</p>
<p>Jeszcze ładniej można to zrobić, korzystając z <code>Object.keys</code> (która to metoda nie szuka niczego w prototypach i zwraca wszystko w postaci normalnej tablicy kluczy):</p>
<pre><code class="language-javascript">var o = {
	a: 1
	,b: 2
	,c: 3
};

Object.keys(o).forEach(function(x)
{
	console.log(o[x]);
});
</code></pre>
<h2 id="namespaces">Funkcje natychmiastowego wywołania i przestrzenie nazw</h2>
<p>Każdy doskonale wie, że zmienne globalne są bleeee. Jednak w wielu skryptach można znaleźć coś takiego:</p>
<pre><code class="language-javascript">var width = 0;
var height = 0;
var img = null;
var elem = null;
//itp.
</code></pre>
<p>Tym sposobem brudzimy sobie globalny scope!</p>
<pre><code class="language-javascript">console.log(window['width']);
</code></pre>
<p>A można lepiej, wykorzystując zasięg zmiennych:</p>
<pre><code class="language-javascript">(function()
{
	var width = 0;
	var height = 0;
	var img = null;
	var elem = null;
}());
console.log(window['width']);
</code></pre>
<p>OK, a jeśli chcemy coś specjalnie umieścić w globalnym scope, np. funkcje naszego super-hiper API? Oczywiście głupim pomysłem jest ładowanie oddzielnie wszystkich 150+ funkcji, bo istnieje szansa, że coś naszego nadpisze funkcje już używane na stronie (np. funkcja o nazwie <code>resizeImg</code>). Wtedy możemy posłużyć się przestrzenią nazw:</p>
<pre><code class="language-javascript">
var API = {
	resizeImg: function()
	{
		console.log('wywołano');
	}
};
API.resizeImg();

</code></pre>
<p>Po połączeniu obydwu metod możemy osiągnąć coś takiego</p>
<pre><code class="language-javascript">(function($)
{
	var API = {}
	,resizeImg = jakiswarunek ? function() {console.log('a');} : function() {console.log(b);};

	API.resizeImg = resizeImg;
	$.API = API;
}(window))
</code></pre>
<p>Voila! W globalnym scope mamy tylko to, co chcieliśmy mieć!</p>
<h2 id="feature-detection">Feature detection</h2>
<blockquote>
Sniffing an user agent is like sniffing a glue
<footer><cite>porneL</cite></footer></blockquote>
<p>Dlatego też, zamiast opierać się na wątpliwym przekonaniu, że w IE 5.5.1733958399 zainstalowanym pod Win XP z SP 14 na pewno to działa, warto sprawdzić czy naprawdę funkcja x istnieje i jest funkcją. Wyobraźmy sobie choćby, że chcemy stworzyć obiekt przy pomocy <code>Object.create</code>, ale nie jesteśmy pewni czy ta metoda istnieje:</p>
<pre><code class="language-javascript">var o = Object.create(null);
</code></pre>
<p>W starszych IE wywali nam ładny ReferrenceError. A wystarczy sprawdzić czy ta metoda istnieje:</p>
<pre><code class="language-javascript">if(typeof Object.create === 'function')
</code></pre>
<p>Jeśli nie, to można walnąć <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create#Polyfill" rel="noreferrer noopener">polyfilla</a>. Na tej samej zasadzie działa cała biblioteka <a href="http://modernizr.com" rel="noreferrer noopener">Modernizr</a>.</p>
<h2 id="delegation">Event delegation</h2>
<p>Zdarzenia bąbelkują (jak ktoś nie wierzy, to niech <a href="http://www.quirksmode.org/js/events_order.html" rel="noreferrer noopener">poczyta</a>). Dlatego też możliwe staje się odkrycie, że jakiś tam akapit w jakimś tam divie został kliknięty.</p>
<pre><code class="language-javascript">(function(d)
{
	d.getElementsByTagName('div')[0].addEventListener('click', function(e)
	{
		var t = e.target;
		if(t.tagName.toLowerCase() === 'p')
			console.log(t.innerHTML);
	}, false);
}(document));
</code></pre>
<p>Kiedy warto tego użyć? Jeśli np. mamy dużo przycisków na stronie i wszystkie są w jednym rodzicu. Zamiast przypisywać zdarzenia do każdego z nich, można przypisać te zdarzenia do ich rodzica i za pomocą <code>e.target</code> (w IE <code>e.srcElement</code>) sprawdzić, co tak naprawdę zostało kliknięte. Przydaje się także przy stronach ajaksowych, gdzie część elementów interaktywnych zostanie dodana po wczytaniu strony. Wtedy można doczepić zdarzenie np. do <code>body</code> i mieć pewność, że każdy przycisk będzie klikalny.</p>

					</div>
				</div>
			</main>

			<footer class="site-footer">
				<div class="container-fluid">
					<p>Copyright © by <a href="https://www.comandeer.pl" rel="author">Comandeer</a>.</p>
				</div>
			</footer>

			<script src="/js/main.js" defer></script>
			<script id="cookiebanner" src="/js/cookies.js" data-message="Używam cookies w celu polepszenia działania witryny." data-linkmsg="Dowiedz się więcej" data-moreinfo="/polityka-prywatnosci.html#pliki-cookies-i-inne-technologie-sledzace" defer></script>
		</body>
	</html>
