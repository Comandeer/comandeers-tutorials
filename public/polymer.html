<!DOCTYPE html>
	<html lang="pl" dir="ltr" class="no-js">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<script>
			(function(H,c){H[c]=H[c].replace(/\bno-js\b/,'')+' js'})(document.documentElement,'className');
			</script>
			<title>WebComponents i Polymer - niespe&#x142;niony sen?</title>
			<meta name="description" content="Przygody Comandeera z tym lepszym frameworkiem od Google.">
			<meta property="og:title" content="WebComponents i Polymer - niespe&#x142;niony sen?">
			<meta property="og:description" content="Przygody Comandeera z tym lepszym frameworkiem od Google.">
			<meta property="og:type" content="article">
			<meta property="article:author" content="Comandeer">

			<meta property="og:url" content="https://tutorials.comandeer.pl/polymer.html">
			<meta property="og:image" content="https://tutorials.comandeer.pl/images/comandeer.jpg">
			<meta property="og:image:width" content="200">
			<meta property="og:image:height" content="200">


			<!--[if lt IE 9]>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
			<![endif]-->
			<link rel="stylesheet" href="/css/main.css">
		</head>
		<body>
			<nav class="navbar navbar-inverse navbar-fixed-top" aria-label="Nawigacja po witrynie">
				<div class="container-fluid">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#site-menu" aria-expanded="false">
							<span class="sr-only">Włącz/wyłącz menu</span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
						<a href="/" class="navbar-brand" title="« Powrót do spisu tutorialów">Tutorials</a>
					</div>

					<div class="collapse navbar-collapse" id="site-menu">
						<ul class="nav navbar-nav"><li><a href="polityka-prywatnosci.html">Polityka prywatności</a></li></ul>
					</div>
				</div>
			</nav>

			<main class="container-fluid">
				<div class="row">
					<div class="col-md-8 col-md-offset-4 header header_main">
						<h1 id="start" class="header__heading">WebComponents i Polymer - niespe&#x142;niony sen?</h1>

						<a class="header__link" href="polymer.pdf" title="Wersja PDF"><span class="glyphicon glyphicon-book" aria-hidden="true"></span><span class="sr-only">Wersja <abbr title="Portable Document Format" lang="en">PDF</abbr></span></a>
					</div>
				</div>
				<div class="row">
					<nav class="sidebar col-md-4 well" aria-labelledby="toc-heading">
			<h2 class="sidebar-header" id="toc-heading">Spis treści</h2>
				<div class="sidebar-inner">
					<ul>
					<li><a href="#start">WebComponents i Polymer - niespe&#x142;niony sen?</a><ul><li><a href="#zalozenia">Za&#x142;o&#x17C;enia a rzeczywisto&#x15B;&#x107;</a></li><li><a href="#polymer">Polymer - wrz&#xF3;d na ty&#x142;ku</a></li><li><a href="#template">Szablony</a></li><li><a href="#shadow-dom">ShadowDOM</a></li><li><a href="#imports">HTML Imports</a></li><li><a href="#dostepnosc">Dost&#x119;pno&#x15B;&#x107;</a></li><li><a href="#co-dalej">I co dalej?</a></li></ul></li>
					</ul>
				</div>
			</nav>

					<div class="content col-md-8 col-md-offset-0">
						<p></p>

<p>Nie tak dawno <a href="http://webroad.pl/javascript/3505-web-components" rel="noreferrer noopener">zachwyca&#x142;em si&#x119; pot&#x119;g&#x105; Web Components</a>, wieszcz&#x105;c im &#x15B;wietlan&#x105; przysz&#x142;o&#x15B;&#x107; w webmasterskim &#x15B;wiecie. Po kilku miesi&#x105;cach u&#x17C;ywania tej technologii przyszed&#x142; czas na pierwsze refleksje i ostudzenie zbyt wcze&#x15B;nie zapalonego entuzjazmu. Trzeba posypa&#x107; g&#x142;ow&#x119; popio&#x142;em i powiedzie&#x107; wprost: &quot;To nie tak mia&#x142;o by&#x107;&quot;.</p>
<h2 id="zalozenia">Za&#x142;o&#x17C;enia a rzeczywisto&#x15B;&#x107;</h2>
<p>Nie ukrywam, &#x17C;e w Web Components od samego pocz&#x105;tku upatrywa&#x142;em nie tyle ca&#x142;kowitej zmiany paradygmatu tworzenia zaawansowanych aplikacji internetowych, co po prostu naturalnej i wymaganej obecnym stanem Sieci ewolucji. Ewolucji na polu <b>tworzenia <a href="http://www.reactivemanifesto.org/" rel="noreferrer noopener">responsywnych</a> interfejs&#xF3;w u&#x17C;ytkownika</b>. Tyle. Tylko tyle i a&#x17C; tyle.</p>
<p>Nigdy nie my&#x15B;la&#x142;em, &#x17C;eby do znacznika m&#xF3;c w&#x142;o&#x17C;y&#x107; logik&#x119; aplikacji, kt&#xF3;ra nijak si&#x119; ma do interfejsu&#x2026; Okaza&#x142;o si&#x119; jednak, &#x17C;e jestem w przyt&#x142;aczaj&#x105;cej mniejszo&#x15B;ci. Wi&#x119;kszo&#x15B;&#x107; komponent&#xF3;w bowiem, kt&#xF3;re mo&#x17C;emy znale&#x17A;&#x107; w Sieci, dotyczy rzeczy, kt&#xF3;re niegdy&#x15B; by&#x142;y domen&#x105; pot&#x119;&#x17C;nych framework&#xF3;w MVW. <a href="http://component.kitchen/components/app-router" rel="noreferrer noopener">Deklaratywny router</a>, kt&#xF3;ry wczytuje strony, b&#x119;d&#x105;ce&#x2026; komponentami? Mo&#x17C;e i pocz&#x105;tkowo ta idea wydaje si&#x119; interesuj&#x105;ca, ale bardzo &#x142;atwo si&#x119; przekona&#x107; jak bardzo strzelamy sobie w kolano, przenosz&#x105;c lwi&#x105; cz&#x119;&#x15B;&#x107; logiki do HTML. To przerost formy nad tre&#x15B;ci&#x105; w swoim najdoskonalszym wydaniu - zamiast zrobi&#x107; normalne linki i normalnie wczytywa&#x107; strony z wykorzystaniem History API, tworzymy rozwi&#x105;zanie problemu, kt&#xF3;ry&#x2026; sami na szybko stwarzamy. Tak, Web Components s&#x105; fajne, ale to nie znaczy, &#x17C;e mamy wszystko na nie przepisa&#x107;, tworz&#x105;c rozwi&#x105;zania niezwykle trudne do rozwijania i utrzymywania. Obawiam si&#x119; jednak, &#x17C;e takie wykorzystanie Web Components b&#x119;dzie si&#x119; stawa&#x107; coraz bardziej popularne (wystarczy tutaj powiedzie&#x107;, &#x17C;e przecie&#x17C; Angular 2.0 b&#x119;dzie intensywnie korzysta&#x142; z Polymera). Czy na pewno chcemy w pe&#x142;ni deklaratywnej Sieci? A je&#x15B;li tak, to dlaczego kiedy&#x15B;&#xA0;protestowali&#x15B;my przeciwko XHTML 2.0?</p>
<h2 id="polymer">Polymer - wrz&#xF3;d na ty&#x142;ku</h2>
<p>Nikt o zdrowych zmys&#x142;ach nie tworzy aplikacji obecnie w &quot;czystych&quot; Web Components. By&#x142;aby to sadomasochistyczna sztuka dla sztuki, poniewa&#x17C; &#x17C;adna przegl&#x105;darka (nawet bleeding edge Chrome) nie wspiera w pe&#x142;ni wszystkich specyfikacji wchodz&#x105;cych w sk&#x142;ad Web Components. Dlatego te&#x17C; de facto wszyscy musz&#x105; u&#x17C;ywa&#x107; jakich&#x15B; polyfill&#xF3;w (profill&#xF3;w?). Nie b&#x119;d&#x119; ukrywa&#x142;, &#x17C;e najpopularniejszym jest <a href="https://www.polymer-project.org/" rel="noreferrer noopener">projekt Polymer</a>, z kt&#xF3;rego korzystaj&#x105; tak&#x17C;e&#x2026; inne polyfiille (takie jak Mozillowe <a href="http://www.x-tags.org/" rel="noreferrer noopener">X-Tags</a> czy <a href="http://bosonic.github.io/" rel="noreferrer noopener">Bosonic</a>). M&#xF3;wi&#x105;c zatem kr&#xF3;tko: na chwil&#x119; obecn&#x105; tworzenie przy u&#x17C;yciu otwartego standardu, jakim s&#x105; Web Components, sprowadza si&#x119; do zamkni&#x119;cia si&#x119; w bibliotece serwowanej przez Google. Otwarta Sie&#x107;, czy&#x17C; nie?</p>
<p>Stosunek Google do ich projekt&#xF3;w wszyscy znamy - w ka&#x17C;dej chwili mog&#x105; je uwali&#x107;. Co wi&#x119;cej, Polymer jest na tyle specyficznym projektem, &#x17C;e - b&#x119;d&#x105;c &quot;na rynku&quot; ju&#x17C; 2 lata - wci&#x105;&#x17C; jest uznawany za skrajnie eksperymentalny. Co to oznacza? &#x17B;e &#x15B;rednio co tydzie&#x144; mo&#x17C;na obudzi&#x107; si&#x119; z r&#x119;k&#x105; w nocniku, po nieuwa&#x17C;nym wklupaniu <code>bower update</code> w konsoli. Tak, Polymer zmienia si&#x119; na pniu. Ostatnio prze&#x17C;y&#x142;em szok, gdy okaza&#x142;o si&#x119;, &#x17C;e jego stare, dobre <code>platform.js</code> odesz&#x142;o na emerytur&#x119;, zostaj&#x105;c zast&#x105;pione bardziej modu&#x142;owym <code>webcomponents.js</code>. G&#x142;&#xF3;wna r&#xF3;&#x17C;nica? Zamiast du&#x17C;ego pliku, Polymer zasysa teraz <b>kilkadziesi&#x105;t</b> ma&#x142;ych. Po prostu wydajno&#x15B;&#x107; maksymalna out of box. Ale oczywi&#x15B;cie in&#x17C;ynierowie Google problem widz&#x105;, dlatego przygotowali dla niego rozwi&#x105;zanie (czy ju&#x17C; wspomina&#x142;em, &#x17C;e w &#x15B;wiecie Web Components lubi si&#x119; rozwi&#x105;zywa&#x107; problemy, kt&#xF3;re samemu si&#x119; wcze&#x15B;niej stworzy&#x142;o?) - <a href="https://www.polymer-project.org/articles/concatenating-web-components.html" rel="noreferrer noopener">Vulcanizer</a>. Oczywi&#x15B;cie to rozwi&#x105;zanie tymczasowe, bo tu&#x17C; za rogiem czeka ju&#x17C; HTTP 2.0 i czego&#x15B; takiego nie trzeba b&#x119;dzie u&#x17C;ywa&#x107;&#x2026; Tak samo, jak od dw&#xF3;ch lat nie powinni&#x15B;my u&#x17C;ywa&#x107; dziwnego owijacza w formie Polymera.</p>
<p>Cz&#x119;ste zmiany to nie tylko sajgon w plikach, ale tak&#x17C;e sajgon przy testowaniu swoich komponent&#xF3;w - Polymer jest podzielony na tak szalon&#x105; ilo&#x15B;&#x107; plik&#xF3;w, &#x17C;e prawie zawsze wyst&#x119;puj&#x105; jakie&#x15B; nieporozumienia z cache. Nieporozumienia na tyle trudne, &#x17C;e a&#x17C; by&#x142;em zmuszony <a href="https://github.com/Comandeer/dGUI/blob/18f8f1c08471bdc8c6b3a6f490203a1cc242bf89/components/.htaccess" rel="noreferrer noopener">wy&#x142;&#x105;czy&#x107; cache dla komponent&#xF3;w</a> - jak na razie nie wr&#xF3;&#x17C;y to dobrze Polymerowi, bo zasysanie go przy ka&#x17C;dym &#x17C;&#x105;daniu od nowa to czysta kpina. Dodajmy do tego konieczno&#x15B;&#x107; importowania tak&#x17C;e samych <a href="http://dgui.comandeer.pl" rel="noreferrer noopener">komponent&#xF3;w dGUI</a> i dostajemy co najmniej 3 sekundy do czasu pokazania czegokolwiek na stronie (bo Polymer &#x142;askawie ukrywa wszystko, a&#x17C; si&#x119; komponenty nie doczytaj&#x105;&#x2026;). <b>O 2.5 sekundy za d&#x142;ugo.</b></p>
<p>I wreszcie - sama konwencja Polymera. <a href="https://github.com/Comandeer/dGUI/blob/18f8f1c08471bdc8c6b3a6f490203a1cc242bf89/components/dgui-keyboard/dgui-keyboard.html" rel="noreferrer noopener">Ka&#x17C;dy komponent</a> to style i JS wrzucone w znacznik <code>polymer-element</code>. Serio? Zwa&#x17C;aj&#x105;c na to jak specyficzne s&#x105; projektowane zastosowania Web Components, uwa&#x17C;am to co najmniej za dziwne (CSP, anyone?). Oczywi&#x15B;cie Vulcanizer jest w stanie si&#x119; tym zaj&#x105;&#x107; (czy ju&#x17C; wspomina&#x142;em o tworzeniu niepotrzebnych problem&#xF3;w?) - pytanie brzmi: czemu to nie jest domy&#x15B;lnym ustawieniem? Nagle z HTML-a zrobiono worek na wszystko. Witamy w XUL-u?</p>
<p>Do tego dochodzi fakt, &#x17C;e ca&#x142;e &#x15B;rodowisko Polymera opiera si&#x119; na Bowerze. Zatem, &#x17C;eby u&#x17C;y&#x107; Polymera musz&#x119; zainstalowa&#x107; node.js, zainstalowa&#x107; bowera przez npm i dopiero w&#xF3;wczas mog&#x119; zainstalowa&#x107; samego Polymera. Na tej samej zasadzie dzia&#x142;aj&#x105; wszelkie komponenty w tym wielkim ekosystemie. Czy to plus, czy minus - to zale&#x17C;y. Czasami bardzo przydaje si&#x119; ustandaryzowany spos&#xF3;b rozprowadzania zale&#x17C;no&#x15B;ci, innym razem jest to kula u nogi.</p>
<p>I na sam koniec, komunikat z dev tools Firefoksa:</p>
<blockquote>
mutating the [[Prototype]] of an object will cause your code to run very slowly; instead create the object with the correct initial [[Prototype]] value using Object.create
<footer><cite>Konsola JS</cite></footer></blockquote>
<p>Nie oszukujmy si&#x119; - &#x17C;eby Web Components dzia&#x142;a&#x142;y, wraz z emulacj&#x105; Shadow DOM, gdzie np. trzeba zatrzyma&#x107; leakage <code>[id]</code> na zewn&#x105;trz, Polymer musi nadpisa&#x107; <b>kilkadziesi&#x105;t prototyp&#xF3;w DOM-owych</b>. Takie zabawy nigdy nie by&#x142;y wydajne, a co wi&#x119;cej s&#x105; nara&#x17C;one na wszelkie mo&#x17C;liwe b&#x142;&#x119;dy (nie bez przyczyny istnieje z&#x142;ota zasada, &#x17C;e prototyp&#xF3;w hosta si&#x119; nie tyka).</p>
<p>Oczywi&#x15B;cie reszta punkt&#xF3;w jest pisana z perspektywy w&#x142;a&#x15B;nie Polymera - jedynej s&#x142;usznej drogi ku Web Components.</p>
<h2 id="template">Szablony</h2>
<p>Pocz&#x105;tkowo idea szablon&#xF3;w w DOM, tworzonych przy pomocy znacznika <code>template</code> brzmi sensownie. Ot, mamy wydzielone na zewn&#x105;trz drzewko DOM, na kt&#xF3;rym mo&#x17C;emy sobie do woli operowa&#x107; i dop&#xF3;ki nie wsadzimy go na stron&#x119;, nic si&#x119; nie dzieje - zdarzenia si&#x119; w nim nie odpalaj&#x105;, obrazki nie wczytuj&#x105;&#x2026; Do tego dostajemy do pracy z nim pot&#x119;&#x17C;ne narz&#x119;dzia zwi&#x105;zane z trawersacj&#x105; drzewka DOM. Precz z p&#x142;askimi stringami, bawimy si&#x119; &#x17C;yw&#x105;&#xA0;struktur&#x105;!</p>
<p>Problem polega na tym, &#x17C;e takie wykorzystanie szablon&#xF3;w jest skrajnie prymitywne i starcza dla podstawowych zastosowa&#x144;. Dlatego w Polymerze wymy&#x15B;lili sobie tzw. &quot;template bindings&quot;, kt&#xF3;re mia&#x142;y by&#x107; zg&#x142;oszone do procesu standaryzacji w W3C, ale wygl&#x105;da na to - ca&#x142;e szcz&#x119;&#x15B;cie - &#x17C;e tam nie dotar&#x142;y. Na czym pomys&#x142; polega? Na tym, &#x17C;eby m&#xF3;c u&#x17C;ywa&#x107; w <code>template</code> uproszczonej sk&#x142;adni <a href="http://mustache.github.io/" rel="noreferrer noopener">w&#x105;s&#xF3;w</a> + logiki ukrytej skrz&#x119;tnie w atrybutach element&#xF3;w. Przyk&#x142;ad prosto z dokumentacji:</p>
<pre><code class="language-&quot;markup&quot;">&lt;template repeat=&quot;{{ foo, i in foos }}&quot;&gt;
	&lt;template repeat=&quot;{{ value, j in foo }}&quot;&gt;
		{{ i }}:{{ j }}. {{ value }}
	&lt;/template&gt;
&lt;/template&gt;
</code></pre>
<p>Oczywi&#x15B;cie to dodatkowo dostaje 2-way data binding. Brzmi fajnie, ale w praktyce to jest piek&#x142;o na ziemi. Wida&#x107; tu 3 powa&#x17C;ne problemy:</p>
<ul>
<li>z systemu DOM-owego niepostrze&#x17C;enie przeszli&#x15B;my z powrotem na parsowanie string&#xF3;w. Tym samym nie ma <b>najmniejszych</b> powod&#xF3;w, &#x17C;eby dalej korzysta&#x107; z tagu <code>template</code> - odebrana nam zostaje jego g&#x142;&#xF3;wna zaleta: DOM. To poci&#x105;ga za sob&#x105; bardzo powa&#x17C;ne konsekwencje, zwi&#x105;zane z debugowaniem takiego kodu (nic niem&#xF3;wi&#x105;ce b&#x142;&#x119;dy o funkcjach anonimowych w funkcjach anonimowych, kt&#xF3;re jeszcze przechodz&#x105; przez <code>eval</code>; bardzo podobny problem dotyka wszystkie JS-owe parsery HTML-owych string&#xF3;w, zatem Angulara, jak i JSX z Reacta). W tym wypadku lepiej skorzysta&#x107; ze standardowych w&#x105;s&#xF3;w.</li>
<li>przenie&#x15B;li&#x15B;my logik&#x119; na poziom HTML-a. Stare, przerabiane i za ka&#x17C;dym razem ten pomys&#x142; upada&#x142; (patrz: Web Forms 2.0 i w&#x142;a&#x15B;nie <code>[repeat]</code> p&#xF3;l). HTML nie s&#x142;u&#x17C;y do takich rzeczy - jest j&#x119;zykiem <b>opisu strony</b>, nie j&#x119;zykiem deklaratywnych szablon&#xF3;w. Od tego jest inny j&#x119;zyk (XSLT - i zn&#xF3;w: czemu odrzucili&#x15B;my XHTML 2.0, a teraz przepisujemy XML na HTML?)</li>
<li>2-way data binding wprowadza wi&#x119;cej problem&#xF3;w ni&#x17C; je rozwi&#x105;zuje. Bindowanie model &#x2192; widok jest naturalne i de facto tak dzia&#x142;aj&#x105; od zawsze wszystkie MVW. Bindowanie model &#x2194; widok ju&#x17C; takie nie jest. Czy model musi odpowiada&#x107; na zmiany, kt&#xF3;re zachodz&#x105; w widoku? <a href="http://stackoverflow.com/questions/19481/is-data-binding-a-bad-idea" rel="noreferrer noopener">To zale&#x17C;y</a>. Niemniej wi&#x105;zanie modelu bezpo&#x15B;rednio z DOM brzmi&#x2026; podejrzanie.</li>
</ul>
<p>Polymer psuje to, co by&#x142;o dobre w <code>template</code>, sprowadzaj&#x105;c go do poziomu rozwi&#x105;za&#x144;, kt&#xF3;re istnia&#x142;y przed nim. A sens <code>template</code> le&#x17C;y w jego DOM-owej naturze, nie w logice wepchni&#x119;tej w ledwo trzymaj&#x105;ce si&#x119; atrybuty.</p>
<h2 id="shadow-dom">ShadowDOM</h2>
<p>ShadowDOM to HTML-owy spos&#xF3;b na enkapsulacj&#x119;. Tym samym tworzymy sobie czarne dziury - konkretny custom element ukrywa przed nami swoj&#x105; implementacj&#x119;, udost&#x119;pniaj&#x105;c nam <a href="https://github.com/Comandeer/dGUI/blob/18f8f1c08471bdc8c6b3a6f490203a1cc242bf89/components/dgui-colorpicker/demo.html#L17" rel="noreferrer noopener">&#x142;adne, eventowe API</a> i nic wi&#x119;cej. Fajna sprawa, je&#x15B;li potrzebujemy konkretnego elementu interfejsu, przy kt&#xF3;rym ca&#x142;kowicie nie interesuje nas jego wewn&#x119;trzny spos&#xF3;b dzia&#x142;ania, a tylko i wy&#x142;&#x105;cznie to, co w zamian dostajemy. Colorpicker jest doskona&#x142;ym tego przyk&#x142;adem (Po co mi, jako autorowi edytora graficznego, potrzebna jest wiedza, &#x17C;e to k&#xF3;&#x142;ko kolor&#xF3;w generowane jest na <code>canvas</code>, przechwytuje zdarzenia myszki itd? Ja po prostu potrzebuj&#x119; narz&#x119;dzia do &#x142;atwego wybierania kolor&#xF3;w!).</p>
<p>Oczywi&#x15B;cie nie mo&#x17C;e by&#x107; za dobrze. Problemy pojawiaj&#x105; si&#x119; bardzo szybko, a&#x17C; za szybko&#x2026; Podstawowym jest spos&#xF3;b obs&#x142;ugi zdarze&#x144; na elemencie, b&#x119;d&#x105;cym shadow rootem. Mo&#x17C;na z g&#xF3;ry zapomnie&#x107; o takich wynalazkach, jak event delegation: zdarzenie przypi&#x119;te do elementu z ShadowDOM zar&#xF3;wno w <code>this</code>, jak i w <code>event.target</code> b&#x119;dzie wskazywa&#x107; na ten element - granicy cienia nie da si&#x119; prze&#x142;ama&#x107;. Bardzo szybko przekona&#x142;em si&#x119; o tym i to do&#x15B;&#x107; bole&#x15B;nie, pr&#xF3;buj&#x105;c naskroba&#x107; sw&#xF3;j 1. Web Component, jakim sta&#x142;a si&#x119; <a href="http://dgui.comandeer.pl/components/dgui-keyboard/demo.html" rel="noreferrer noopener">klawiatura ekranowa</a>: odczytanie kt&#xF3;ry dok&#x142;adnie klawisz zosta&#x142; wci&#x15B;ni&#x119;ty nagle okaza&#x142;o si&#x119; zaj&#x119;ciem dosy&#x107; karko&#x142;omnym. Cie&#x144; udost&#x119;pnia co prawda metody do pobierania jego dzieci i mo&#x17C;na bezpo&#x15B;rednio do nich przypina&#x107; zdarzenia, jednak ma to dwie wady: musimy pobra&#x107; wszystkie potrzebne nam dzieci i musimy do ka&#x17C;dego przypi&#x105;&#x107; konkretne zdarzenie (&#x142;atwo policzy&#x107;, &#x17C;e dla kilku instancji takiej klawiatury na stronie b&#x119;dziemy mieli ponad 100 zdarze&#x144; dla samych klawiszy!). Niezbyt wydajne, ale w ostateczno&#x15B;ci da si&#x119; przebole&#x107;.</p>
<p>Polymer nie by&#x142;by jednak sob&#x105;, gdyby nie zaoferowa&#x142; szybkiego, wygodnego i <b>ca&#x142;kowicie nieprzemy&#x15B;lanego</b> rozwi&#x105;zania. Mowa o atrybutach <code>[on-[event]]</code> dla ka&#x17C;dego elementu z ShadowDOM, kt&#xF3;re musi mie&#x107; zdarzenie. Mam wra&#x17C;enie, &#x17C;e <a href="https://pornel.net/onclick" rel="noreferrer noopener">gdzie&#x15B; to ju&#x17C; widzia&#x142;em</a>. Wracamy do mieszania warstwy zachowania z&#x2026; no w&#x142;a&#x15B;nie - czym jest HTML w Web Components? Bo im bardziej wg&#x142;&#x119;biam si&#x119; w ten temat, tym bardziej mam wra&#x17C;enie, &#x17C;e HTML jest tutaj zawoalowanym odpowiednikiem JS. Niemniej te atrybuty jak dot&#x105;d s&#x105; jedyn&#x105; sensown&#x105; metod&#x105; dowi&#x105;zywania zdarze&#x144; do element&#xF3;w w ShadowDOM (nie licz&#x105;c iterowania po wszystkich mo&#x17C;liwych w&#x119;z&#x142;ach shadow roota, co w Polymerze jest tak zgrabnie ukryte, &#x17C;e i tak lepiej doda&#x107; te atrybuty). S&#x105;dz&#x119; jednak, &#x17C;e <code>[on-click=&quot;{{clicker}}&quot;]</code> wci&#x105;&#x17C; wygl&#x105;da lepiej ni&#x17C; <code>[ng-click=&quot;function()&quot;]</code> - bo co do tego drugiego nie mamy &#x17C;adnych w&#x105;tpliwo&#x15B;ci, &#x17C;e ca&#x142;o&#x15B;&#x107; przechodzi przez <code>eval</code>.</p>
<p>Warto tu tak&#x17C;e wspomnie&#x107; o dost&#x119;pnym w ka&#x17C;dym elemencie <code>this.$</code>, przechowuj&#x105;cym referencje do wszystkich element&#xF3;w Shadow DOM, kt&#xF3;re maj&#x105; nadane <code>[id]</code>. Mi&#x142;y akcent, jednak raczej bym oszala&#x142; dodaj&#x105;c <code>[id]</code> do ka&#x17C;dego elementu.</p>
<h2 id="imports">HTML Imports</h2>
<p>HTML Imports s&#x105; HTML-ow&#x105; wersj&#x105; modu&#x142;&#xF3;w CJS - s&#x105; synchroniczne z natury. Problem polega na tym, &#x17C;e naturalnie wyst&#x119;puj&#x105; tylko w Chrome i tylko w nim s&#x105; synchroniczne. Wszystkie inne przegl&#x105;darki dostaj&#x105; zatem rozwi&#x105;zanie asynchroniczne. Co to oznacza? Problemy.</p>
<p>Postanowi&#x142;em w dGUI pewne wsp&#xF3;lne helpery i inne tego typu dziwne rzeczy wydzieli&#x107; do osobnego pliku JS i importowa&#x107; go jako w&#x142;a&#x15B;nie HTML Import. Szcz&#x119;&#x15B;liwy, &#x17C;e dzia&#x142;a w Chrome, scomittowa&#x142;em zmiany. Oczywi&#x15B;cie w lisku nie dzia&#x142;a&#x142;o. Czemu? Z prostej przyczyny - wiedz&#x105;c, &#x17C;e importy s&#x105; synchroniczne, pozwoli&#x142;em sobie na za&#x142;o&#x17C;enie, &#x17C;e globalny obiekt <code>dGUI</code> (tak, globalny obiekt - je&#x15B;li kto&#x15B; mi poka&#x17C;e sensowny przyk&#x142;ad wykorzystania UMD/AMD z Web Components, bez setki niepotrzebnych udziwnie&#x144;, w&#xF3;wczas ch&#x119;tnie to zmieni&#x119;) istnieje. W lisku ewidentnie nie by&#x142;o to prawd&#x105;, bo ca&#x142;e importy fallbackuj&#x105; tam do &#x17C;&#x105;da&#x144; Ajaksem. Tym sposobem skrypt si&#x119; wyglebi&#x142;.</p>
<p>Zatem je&#x15B;li chcemy si&#x119; pobawi&#x107; w dynamiczne zasysanie skrypt&#xF3;w przy pomocy HTML Imports, a od tych skrypt&#xF3;w zale&#x17C;e&#x107; ma ca&#x142;y nasz skomplikowany system, to lepiej zawczasu przygotowa&#x107; si&#x119; na dziwne zabawy z asynchroniczno&#x15B;ci&#x105; (zdarzenia, wdro&#x17C;enie mimo wszystko AMD itp. dziwne praktyki, ocieraj&#x105;ce si&#x119; o voodoo).</p>
<h2 id="dostepnosc">Dost&#x119;pno&#x15B;&#x107;</h2>
<p>Web Components to nie HTML. Tutaj nie ma &#x17C;adnych warto&#x15B;ci semantycznych - wszystko nale&#x17C;y budowa&#x107; od podstaw. Co to oznacza? ARIA, naprawd&#x119; sporo ARIA. I to do oznaczenia rzeczy najbardziej podstawowych, od zera. Taka jest cena za innowacj&#x119;.</p>
<h2 id="co-dalej">I co dalej?</h2>
<p>Web Components, jako zbi&#xF3;r naprawd&#x119; nowych technologii, cierpi na bardzo powa&#x17C;ne problemy wieku dzieci&#x119;cego. Mimo wszystko uwa&#x17C;am jednak, &#x17C;e - gdy w ko&#x144;cu sytuacja si&#x119; ustabilizuje - stanie si&#x119; sensownym sposobem na implementacj&#x119; zenkapsulowanego, wydajnego i prostego w u&#x17C;yciu interfejsu u&#x17C;ytkownika. Mam tak&#x17C;e nadziej&#x119;, &#x17C;e inni webmasterzy r&#xF3;wnie&#x17C; dojd&#x105; do tego samego wniosku i przestan&#x105; przepisywa&#x107; na Web Components wszystko, &#x142;&#x105;cznie z rzeczami, kt&#xF3;re nigdy nie powinny by&#x107; deklaratywne. Na razie jednak Web Components pozostaj&#x105; ciekawostk&#x105; - pot&#x119;&#x17C;n&#x105;, lecz tylko ciekawostk&#x105;. Jedynym sensownym jej u&#x17C;yciem prawdopodobnie s&#x105; &#x15B;ci&#x15B;le kontrolowane &#x15B;rodowiska (typu <a href="https://github.com/rogerwang/node-webkit" rel="noreferrer noopener">node-webkit</a>). I na tym jak na razie zakres stosowania Web Components si&#x119; ko&#x144;czy.</p>
<p>Sama technologia nie jest z&#x142;a - wi&#x119;kszo&#x15B;&#x107; tutaj opisanych zarzut&#xF3;w de facto tyczy si&#x119; Polymera a nie Web Components per se. Niemniej - nie ma obecnie jakiegokolwiek sensu pisa&#x107; w Web Components nie u&#x17C;ywaj&#x105;c Polymera. I ko&#x142;o si&#x119; zamyka. W przysz&#x142;o&#x15B;ci pewnie powstan&#x105; lekkie i o wiele przyja&#x17A;niejsze wrappery na Web Components ni&#x17C; Polymer. No w&#x142;a&#x15B;nie - wrappery. A do tego jeszcze bardzo d&#x142;uga droga, po wyboistych grzbietach polyfill&#xF3;w&#x2026;</p>

					</div>
				</div>
			</main>

			<footer class="site-footer">
				<div class="container-fluid">
					<p>Copyright © by <a href="https://www.comandeer.pl" rel="author">Comandeer</a>.</p>
				</div>
			</footer>

			<script src="/js/main.js" defer></script>
			<script id="cookiebanner" src="/js/cookies.js" data-message="Używam cookies w celu polepszenia działania witryny." data-linkmsg="Dowiedz się więcej" data-moreinfo="/polityka-prywatnosci.html#pliki-cookies-i-inne-technologie-sledzace" defer></script>
		</body>
	</html>
