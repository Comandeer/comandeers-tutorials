<!DOCTYPE html>
	<html lang="pl" dir="ltr" class="no-js">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<script>
			(function(H,c){H[c]=H[c].replace(/\bno-js\b/,'')+' js'})(document.documentElement,'className');

			if ( location.host === 'tutorials.comandeer.pl' ) {
				(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
				(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
				})(window,document,'script','//www.google-analytics.com/analytics.js','ga');


				ga('create', 'UA-33158520-2', 'auto');
				ga('send', 'pageview');
			}

			/*
			 Details primitive polyfill by Comandeer
			 */
			"open"in document.createElement("details")||document.addEventListener("DOMContentLoaded",function(){try{[].forEach.call(document.querySelectorAll("details"),function(e){var t=e.querySelector("summary"),n=function(n){n?(e.removeAttribute("open"),t.setAttribute("aria-expanded",!1)):(e.setAttribute("open","open"),t.setAttribute("aria-expanded",!0))},i=function(){n(e.hasAttribute("open"))};n(!e.hasAttribute("open")),t.setAttribute("tabindex",0),t.setAttribute("role","button"),t.addEventListener("click",i),t.addEventListener("keyup",function(e){-1!==[13,32].indexOf(e.keyCode)&&(e.preventDefault(),this.click())})})}catch(e){}})
			</script>
			<title>[JavaScript] Ukrywanie ciała funkcji</title>
			<!--[if lt IE 9]>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
			<![endif]-->
			<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
			<link rel="stylesheet" href="/css/prism.css">
			<link rel="stylesheet" href="/css/bs/custom.css">
		</head>
		<body>
			<header class="navbar navbar-inverse navbar-fixed-top">
				<div class="container-fluid">
					<div class="navbar-header">
						<a href="/" class="navbar-brand" title="« Powrót do spisu tutoriali">Tutorials</a>
					</div>
				</div>
			</header>

			<div class="container-fluid">
				<div class="row">
					<div class="col-md-8 col-md-offset-2">
						<h1 id="start">[JavaScript] Ukrywanie ciała funkcji</h1>
					</div>
				</div>
				<div class="row">
					

					<main class="col-md-8 col-md-offset-2">
						<article>
						<div class="header"> <a class="header__link" href="#start" title="Bezpo&#x15B;redni link do sekcji"><span class="glyphicon glyphicon-link" aria-hidden="true"></span><span class="sr-only">Bezpośredni link do sekcji</span></a></div>

<p class="alert alert-danger">Niestety, w nowych wersjach Chrome ta metoda już nie działa i dostajemy pełen dostęp do ciała funkcji.</p>
<p class="alert alert-info">Na wstępie uprzedzę, że technika ta nie powstała w mym płodnym umyśle. Została znaleziona przez <a href="http://web.archive.org/web/20130907212310/http://my.opera.com/hallvors/blog/2012/03/20/debugging-maps-google-maps" rel="noopener noreferrer" class="alert-link">developera Opery</a> w czasie debugowania pewnego upierdliwego błędu w działaniu Google Maps w tejże przeglądarce. Jak nietrudno zgadnąć, zostało to w bólach znalezione w źródle tego zaawansowanego webappa. Ja jedynie postanowiłem to wykorzystać na szerszą skalę. Trzeba też zaznaczyć, że technika ta jest średnio przydatna jeśli nie zaciemnimy równocześnie źródła skryptu (np. poprzez uglify.js czy też GCC).</p>
<p>O co wgl chodzi? A no chodzi o pewną magiczną właściwość poniższego fragmentu kodu:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">Function.prototype</code></pre>
<p>Niby co w tym takiego nadzwyczajnego? Już mówię!</p>
<p class="code">Kod:</p><pre><code class="language-javascript">console.log( Function.prototype.call.apply( Function.prototype.bind, &#91; function(){} &#93; ) );</code></pre>
<p>Zapewne w większości powyższy kod wzbudza podświadomy lęk. Przyznać trzeba, że naprawdę wygląda dość dziwacznie. Ale postaram się troszkę przybliżyć jego sens.</p>
<p>Zacznijmy od <code>Function.prototype</code>. Jak już kiedyś wspomniałem, JS jest takim mocno zboczonym językiem, gdzie wszystko jest obiektem. Nic zatem dziwnego, że funkcje są tak naprawdę… obiektami "klasy" <code>Function</code> ("klasy", bo jak wiadomo ECMAScript to jedyna grupa języków prototypowanych). Zatem każda zmiana w prototypie tego globalnego obiektu będzie dziedziczona przez wszystkie funkcje. Jednak tutaj skrypterzy Google poszli o krok dalej i wywołują poszczególne metody prosto z prototypu (czasami, ale to bardzo rzadko, okazuje się to przydatne)!</p>
<p>Zatem jakie metody się tu wywołuje? <code>call</code>, <code>apply</code> i <code>bind</code>. Wszystkie działają dość podobnie i ich głównym zadaniem jest zmienienie kontekstu wywołania funkcji (<code>this</code>). Już wyjaśniam na przykładzie:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var d = { n: 1 };

function g() {
	console.log( this );
}

g.apply( d );</code></pre>
<p>To wywołanie funkcji wyrzuci do konsoli obiekt <code>d</code> zamiast standardowego <code>window</code>.Dość użyteczne, pod warunkiem, że pisze się obiektowy JS i trochę kojarzy pojęcie kontekstu wywołania. Dla nas jednak nie jest to aż tak ważne. Wystarczy wiedzieć, że <code>apply</code> przyjmuje jako pierwszy parametr obiekt, który ma zastąpić nam <code>this</code>, a drugim parametrem jest tablica parametrów wywoływanej funkcji. Przykład, bo brzmi to dziwnie:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">function g( r ) {
	console.log( r );
};

g.apply( window, &#91; 'whatever' &#93; );</code></pre>
<p>W konsoli ujrzymy wspaniały napis <code>whatever</code>. <code>call</code> w zasadzie działa tak samo, ale zamiast tablicy parametrów, przyjmuje ich listę:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">function g( r ) {
	console.log( r );
};

g.call( window, 'whatever' );</code></pre>
<p>Efekt identyczny jak w poprzednim przykładzie. Trochę inaczej działa <code>bind</code>, ponieważ nie wywołuje funkcji w podanym kontekście, a zwraca jej "klona", działającego w danym scope. Dla kompletności przykład, z wiadomym wynikiem:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">function g( r ) {
	console.log( r );
};
( g.bind( window, &#91; 'whatever' &#93; ) )();</code></pre>
<p>Zatem gdy trochę się wysili szare komórki, można dojść do pewnego uogólnienia, że w bardzo zawoalowany sposób po prostu wywołujemy <code>Function.prototype.bind</code>.</p>
<p>OK, a teraz gwóźdź programu: co nam daje połączenie tych trzech metod? A no, przy dobrze zaciemnionym kodzie bardzo utrudnia podejrzenie działania naszych funkcji i ukrywa to przed debuggerami. Kod</p>
<p class="code">Kod:</p><pre><code class="language-javascript">console.log( Function.prototype.call.apply( Function.prototype.bind, &#91; function() {} &#93; ) );</code></pre>
<p>zwróci nam bowiem nic nie mówiące</p>
<p class="code">Kod:</p><pre><code class="language-javascript">function() { &#91;native code&#93; }</code></pre>
<p>Chyba nie muszę mówić jaką konsternację na twarzy młodocianego hakiera zrobi informacja, że nasza super-hiper-tajna funkcja, w której zaimplementowaliśmy czekający na opatentowanie algorytm, uparcie twierdzi, że jest funkcją wbudowaną i to na dodatek bez nazwy!</p>
<p>I zanim polecisz opakowywać wszystkie swoje funkcje w ten sposób, wiadro zimnej wody dla ochłody: <b>KOMPATYBILNOŚĆ</b>. Tak, wiem, że wiesz, że ja wiem, że wiesz, że nie działa to w IE &lt; 9 – przecież to logiczne! Ale niestety rynek tych przeglądarek wciąż jest dośc spory. Toteż – dla własnej wygody i kompatybilności – napiszmy sobie prostą funkcję pomocniczą. Nazwijmy ją (a jakże!) <code>obfuscate</code>. Użyjemy tu dwóch bardziej zaawansowanych elementów JS: funkcji natychmiastowego wywołania oraz closures (i w tym miejscu większość mniej zdeterminowanych postanowiła zamknąć tą kartę przeglądarki). Niech Was nie zwiodą pozory – wcale to (aż tak) trudne nie będzie! Na początku zadeklarujmy sobie swoją funkcję:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = ( function() {
}() );</code></pre>
<p>To jest właśnie tzw. funkcja natychmiastowego wywołania (IIFE – Immediately Invoked Function Expression). Jak nietrudno zgadnąć, nazywa się tak, bo od razu po zadeklarowaniu jest wywoływana (to tak naprawdę jest wywołanie funkcji anonimowej). Na razie nasz kod jest bezużyteczny, bo zmienna <code>obfuscate</code> będzie miała wartość <code>undefined</code>. Toteż trzeba dodać do naszej funkcji <code>return</code>:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = ( function() {
	return function( func ) {
		return Function.prototype.call.apply( Function.prototype.bind, &#91; func &#93; );
	};
}() )</code></pre>
<p>Tak, to jest właśnie closure – funkcja zwracana przez inną funkcję, zamknięta w jej obszarze (no ej, w końcu to technika od samego Google; nikt nie mówił, że łatwo będzie). Tak naprawdę, gdy JS się wczyta, przeglądarka otrzyma coś takiego:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = function( func ) {
	return Function.prototype.call.apply( Function.prototype.bind, &#91; func &#93; );
}</code></pre>
<p>Czemu zatem nie zapisałem tego w taki sposób? Otóż przez IE 8 tak nie zapisałem! Trzeba przecież sprawdzić czy ta metoda ukrywania kodu jest wspierana i w zależności od tego funkcja <code>obfuscate</code> przyjąć może dwie postaci:</p>
<ul>
	<li> zaciemni nam kod,
	</li><li> zwróci niezaciemniony kod.
</li></ul>
<p>A jak sprawdzić czy technika jest obsługiwana? Można sprawdzić czy przeglądarka wysypie się na wywołaniu zaciemnionej w taki sposób funkcji. Ok, ale to nam zatrzyma wykonywanie skryptu… chyba że wrzucimy do tego obsługę wyjątków!</p>
<p class="code">Kod:</p><pre><code class="language-javascript">try {
	Function.prototype.call.apply( Function.prototype.bind, &#91; function() {} &#93; )();
} catch ( err ) {}</code></pre>
<p>Dobra, zwracanie niezaciemnionego kodu jest łatwe – wystarczy zwrócić parametr <code>func</code>. Tyle. Zatem po połączeniu wszystkiego razem, otrzymamy coś takiego:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = ( function() {
	var a = Function.prototype;

	try {
		a.call.apply( a.bind, &#91; function() {} &#93; )();
	} catch ( err ) {
		return function( func ) {
			return func;
		};
	}

	return function( func ) {
		return a.call.apply( a.bind, &#91; func &#93; );
	};
}() );</code></pre>
<ul>
	<li> Najpierw przypisujemy sobie <code>Function.prototype</code> do zmiennej <code>a</code> (żeby się później nie napisać i oszczędzić te parę bajtów).
	</li><li> Sprawdzamy, czy obfuskacja w ogóle działa w bloku <code>try</code>/<code>catch</code>. Jeśli nie, jak gdyby nigdy nic zwracamy funkcję zwracającą parametr <code>func</code> (nieźle to brzmi).
	</li><li> W innych przypadkach po prostu zwracamy funkcję zwracającą zaciemnioną funkcję
</li></ul>
<p>Przykład:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var f = obfuscate( function( n, r ) {
	return n + ':' + r;
} );
console.log( f( 'r', 't' ) ); // "r:t"
console.log( f ); // function () { &#91;native code&#93; }</code></pre>
<p>Demo online nie wstawiam, bo raczej za dynamiczne by nie było.</p>
<p>Aaaaa, i taka uwaga na koniec: moja funkcja <code>obfuscate</code> bardzo lubi strict mode!</p>

						</article>
						<section id="komentarze">
							<h2>Komentarze</h2>
							<div id="disqus_thread"></div>
							<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
							<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
						</section>
					</main>
				</div>
			</div>

			<footer class="site-footer">
				<div class="container-fluid">
					<p>Copyright © by <a href="https://www.comandeer.pl" rel="author">Comandeer</a>.</p>
				</div>
			</footer>

			<script>
			( function() {
				try {
					var codes = document.getElementsByClassName( 'code' );

					[].forEach.call( codes, function( code ) {
						var next = code.nextElementSibling;

						if ( !next || next.tagName.toLowerCase() !== 'pre' || next.scrollHeight < 300 ) {
							return false;
						}

						code.innerHTML = code.innerHTML.replace( ':', ' <span class="code-switch">[Rozwiń]</span>:' );
						code.getElementsByTagName( 'span' )[ 0 ].toSwitch = next;
					} );

					document.addEventListener( 'click', function( evt ) {
						if ( !evt.target || !evt.target.classList.contains( 'code-switch' ) ) {
							return true;
						}

						evt.preventDefault();

						var target = evt.target,
							next = target.toSwitch,
							html = target.innerHTML;

						if ( !next || next.tagName.toLowerCase() !== 'pre' ) {
							return false;
						}

						next.classList.toggle( 'expanded' );
						target.innerHTML = ( html === '[Zwiń]' ? '[Rozwiń]' : '[Zwiń]' );
					} );

					//defer loading of disqus

					if ( location.host === 'tutorials.comandeer.pl' ) {
						window.disqus_shortname = 'comandeerowa';

						var dsq = document.createElement( 'script' );

						dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';

						( document.getElementsByTagName( 'head' )[ 0 ] || document.getElementsByTagName( 'body' )[ 0 ] ).appendChild( dsq );
					}
				} catch( err ) {}
			} () );
			</script>
			<script src="https://code.jquery.com/jquery-1.12.0.min.js" integrity="sha384-XxcvoeNF5V0ZfksTnV+bejnCsJjOOIzN6UVwF85WBsAnU3zeYh5bloN+L4WLgeNE" crossorigin="anonymous"></script>
			<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
			<script>
			$( 'nav' ).on( 'affix.bs.affix', function() {
				$( 'main' ).removeClass( 'col-md-offset-0' ).addClass( 'col-md-offset-4' );
			} ).on( 'affix-top.bs.affix affix-bottom.bs.affix', function() {
				$( 'main' ).removeClass( 'col-md-offset-4' );
			} ).affix( {
				offset: {
					top: function() {
						return ( this.top = $( '.navbar-fixed-top' ).outerHeight( true ) + 10 );
					},
					bottom: function () {
						return ( this.bottom = $( '.site-footer' ).outerHeight( true ) + 10 );
					}
				}
			} )
			</script>
			<script src="/js/prism.js"></script>
		</body>
	</html>
