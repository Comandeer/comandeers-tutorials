<!DOCTYPE html>
	<html lang="pl" dir="ltr" class="no-js">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<script>
			(function(H,c){H[c]=H[c].replace(/\bno-js\b/,'')+' js'})(document.documentElement,'className');

			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-33158520-2', 'auto');
			ga('send', 'pageview');

			/*
			 Details primitive polyfill by Comandeer
			 */
			"open"in document.createElement("details")||document.addEventListener("DOMContentLoaded",function(){try{[].forEach.call(document.querySelectorAll("details"),function(e){var t=e.querySelector("summary"),n=function(n){n?(e.removeAttribute("open"),t.setAttribute("aria-expanded",!1)):(e.setAttribute("open","open"),t.setAttribute("aria-expanded",!0))},i=function(){n(e.hasAttribute("open"))};n(!e.hasAttribute("open")),t.setAttribute("tabindex",0),t.setAttribute("role","button"),t.addEventListener("click",i),t.addEventListener("keyup",function(e){-1!==[13,32].indexOf(e.keyCode)&&(e.preventDefault(),this.click())})})}catch(e){}})
			</script>
			<title>[JavaScript] Ukrywanie ciała funkcji </title>
			<!--[if lt IE 9]>
				<script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
			<![endif]-->
			<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
			<link rel="stylesheet" href="/css/prism.css">
			<style>
			body {
				padding-top: 60px;
			}
			.navbar-brand {
				margin: 0;
			}
			.navbar-brand a {
				color: #9d9d9d;
			}
			.site-footer {
				margin-top: 50px;
				padding: 50px 0;
				background: #222;
				color: #9d9d9d;
			}
			.site-footer a {
				color: #fff;
			}
			nav.affix {
				position: static !important;
			}
			@media screen and (min-width: 992px) {
				nav.affix {
					position: fixed !important;
				}
				nav.affix {
					right: 0;
					top: 60px;
					bottom: 0;
				}
				nav.affix .sidebar-header {
					height: 40px;
				}
				nav.affix .sidebar-inner {
					position: absolute;
					top: 80px;
					bottom: 0;
					overflow: auto;
				}
			}
			
			h1[id] a, h2[id] a, h3[id] a, h2[id] a, h3[id] a, h4[id] a, h5[id] a, h6[id] a {
				opacity: 0;
				transition: opacity .7s ease-in-out;
			}
			h1[id]:hover a, h2[id]:hover a, h3[id]:hover a, h4[id]:hover a, h5[id]:hover a, h6[id]:hover a {
				opacity: .6;
			}
			.code-switch {
				cursor: pointer;
			}
			.code-switch {
				font-size: smaller;
				font-weight: bold;
			}
			pre {
				max-height: 300px;
				overflow: auto;
			}
			pre.expanded {
				max-height: 99999px;
			}
			.code,.quote {
				margin-top: 5px;
			}
			ul li {
				list-style-image: url(/images/bullet.gif);
			}
			</style>
		</head>
		<body>
			<header class="navbar navbar-inverse navbar-fixed-top">
				<div class="container-fluid">
					<div class="navbar-header">
						<h1 class="navbar-brand"><a href="/" title="« Powrót do spisu tutoriali">Tutorials</a></h1>
					</div>
				</div>
			</header>

			<div class="container-fluid">
				<div class="row">
					<main class="col-md-8">
						<article>
						<h1 id="start">[JavaScript] Ukrywanie ciała funkcji <a href="#start" title="Bezpo&#x15B;redni link do sekcji"><span class="glyphicon glyphicon-link" aria-hidden="true"></span><span class="sr-only">Bezpośredni link do sekcji</span></a></h1>
<p class="alert alert-info">Na wstępie uprzedzę, że technika ta nie powstała w mym płodnym umyśle ;) Została znaleziona przez <a href="http://web.archive.org/web/20130907212310/http://my.opera.com/hallvors/blog/2012/03/20/debugging-maps-google-maps" class="alert-link">developera Opery</a> w czasie debugowania pewnego upierdliwego błędu w działaniu Google Maps w tejże przeglądarce. Jak nie trudno zgadnąć, zostało to w bólach znalezione w źródle tego zaawansowanego webappa. Ja jedynie postanowiłem to wykorzystać na szerszą skalę :D Trzeba też zaznaczyć, że technika ta jest średnio przydatna jeśli nie zaciemnimy równocześnie źródła skryptu (np. poprzez uglify.js czy też GCC).</p>
<p>O co wgl chodzi? A no chodzi o pewną magiczną właściwość poniższego fragmentu kodu:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">Function.prototype</code></pre>
<p>Niby co w tym takiego nadzwyczajnego? Już mówię!</p>
<p class="code">Kod:</p><pre><code class="language-javascript">console.log(Function.prototype.call.apply(Function.prototype.bind, &#91;function(){}&#93;);</code></pre>
<p>Zapewne w większości powyższy kod wzbudza podświadomy lęk ;) Przyznać trzeba, że naprawdę wygląda dość dziwacznie. Ale postaram się troszkę przybliżyć jego sens.</p>
<p>Zacznijmy od <code>Function.prototype</code>. Jak już kiedyś wspomniałem, JS jest takim mocno zboczonym językiem, gdzie wszystko jest obiektem. Nic zatem dziwnego, że funkcje są tak naprawdę... obiektami "klasy" <code>Function</code> ("klasy", bo jak wiadomo ECMAScript to jedyna grupa języków prototypowanych). Zatem każda zmiana w prototypie tego globalnego obiektu będzie dziedziczona przez wszystkie funkcje. Jednak tutaj skrypterzy Google poszli o krok dalej i wywołują poszczególne metody prosto z prototypu! (czasami, ale to bardzo rzadko, okazuje się to przydatne).</p>
<p>Zatem jakie metody się tu wywołuje? <code>call</code>, <code>apply</code> i <code>bind</code>. Wszystkie działają dość podobnie i ich głównym zadaniem jest zmienienie kontekstu wywołania funkcji (<code>this</code>). Już wyjaśniam na przykładzie:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var d = {n: 1}
,g = function() {console.log(this);}
g.apply(d);</code></pre>
<p>To wywołanie funkcji wyrzuci do konsoli obiekt <code>d</code>, zamiast standardowego <code>window</code>.Dość użyteczne, pod warunkiem, że pisze się obiektowy JS i trochę kojarzy pojęcie kontekstu wywołania ;) Dla nas jednak nie jest to aż tak ważne. Wystarczy wiedzieć, że <code>apply</code> przyjmuje jako pierwszy parametr obiekt, który ma zastąpić nam <code>this</code>, a drugim parametrem jest tablica parametrów wywoływanej funkcji. Przykład, bo brzmi to dziwnie:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var g = function(r) {console.log(r);};
g.apply(window,&#91;'whatever'&#93;);</code></pre>
<p>W konsoli ujrzymy wspaniały napis <code>whatever</code>. <code>call</code> w zasadzie działa tak samo, ale zamiast tablicy parametrów, przyjmuje ich listę:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var g = function(r) {console.log(r);};
g.call(window, 'whatever');</code></pre>
<p>Efekt identyczny jak w poprzednim przykładzie ;) Trochę inaczej działa <code>bind</code>, ponieważ nie wywołuje funkcji w podanym kontekście, a zwraca jej "klona", działającego w danym scope. Dla kompletności przykład, z wiadomym wynikiem:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var g = function(r) {console.log(r);};
(g.bind(window,&#91;'whatever'&#93;))();</code></pre>
<p>Zatem gdy trochę się wysili szare komórki, można dojść do pewnego uogólnienia, że w bardzo zaowalowany sposób po prostu wywołujemy <code>Function.prototype.bind</code> ;)</p>
<p>Ok, a teraz gwóźdź programu: co nam daje połączenie tych trzech metod? A no, przy dobrze zaciemnionym kodzie bardzo utrudnia podejrzenie działania naszych funkcji i ukrywa to przed debuggerami. Kod</p>
<p class="code">Kod:</p><pre><code class="language-javascript">console.log(Function.prototype.call.apply(Function.prototype.bind, &#91;function(){}&#93;);</code></pre>
<p>zwróci nam bowiem nic nie mówiące</p>
<p class="code">Kod:</p><pre><code class="language-javascript">function() { &#91;native code&#93; }</code></pre>
<p>Chyba nie muszę mówić jaką konsternację na twarzy młodocianego hakiera zrobi informacja, że wasza super-hiper-tajna funkcja, w której zaimplementowaliście czekający na opatentowanie algorytm, uparcie twierdzi, że jest funkcją wbudowaną i to na dodatek bez nazwy! ;)</p>
<p>I zanim polecisz opakowywać wszystkie swoje funkcje w ten sposób, wiadro zimnej wody dla ochłody: <b>KOMPATYBILNOŚĆ</b>. Tak, wiem, że wiesz, że ja wiem, że wiesz, że nie działa to w IE &lt; 9 - przecież to logiczne! Ale niestety rynek tych przeglądarek wciąż jest dośc spory. Toteż - dla własnej wygody i kompatybilności - napiszmy sobie prostą funckję pomocniczą. Nazwijmy ją (a jakże!) <code>obfuscate</code>. Użyjemy tu dwóch bardziej zaawansowanych elementów JS: funkcji natychmiastowego wywołania oraz closures (i w tym miejscu większość mniej zdeterminowanych postanowiła zamknąć tą kartę przeglądarki :D). Niech was nie zwiodą pozory - wcale to (aż tak) trudne nie będzie! Na początku zadeklarujmy sobie swoją funkcję:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = (function()
{
}())</code></pre>
<p>To jest właśnie tzw. funkcja natychmiastowego wywołania (IIFE - Immediately Invoked Function Expression). Jak nie trudno zgadnąć, nazywa się tak, bo od razu po zadeklarowaniu jest wywoływana (to tak naprawdę jest wywołanie funkcji anonimowej ;)). Na razie nasz kod jest bezużyteczny, bo zmienna <code>obfuscate</code> będzie miała wartość <code>undefined</code>. Toteż trzeba dodać do naszej funkcji <code>return</code></p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = (function()
{
	return function(f)
	{
		return Function.prototype.call.apply(Function.prototype.bind, &#91;f&#93;);
	}
}())</code></pre>
<p>Tak, to jest właśnie closure - funkcja zwracana przez inną funkcję, zamkniętą w jej obszarze (no ej, w końcu to technika od samego Google :D nikt nie mówił, że łatwo będzie). Tak naprawdę, gdy JS się wczyta, przeglądarka otrzyma coś takiego:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = function(f)
{
	return Function.prototype.call.apply(Function.prototype.bind, &#91;f&#93;);
}</code></pre>
<p>Czemu zatem nie zapisałem tego w taki sposób? Otóż przez IE 8 tak nie zapisałem! Trzeba przecież sprawdzić czy ta metoda ukrywania kodu jest wspierana i w zależności od tego funkcja <code>obfuscate</code> przyjąć może dwie postaci:</p>
<ul>
<li> zaciemni nam kod
</li><li> zwróci niezaciemniony kod
</li></ul>
<p>A jak sprawdzić czy technika jest obsługiwana? Można sprawdzić czy przeglądarka wysypie się na wywołaniu zaciemnionej w taki sposób funkcji. Ok, ale to nam zatrzyma wykonywanie skryptu... chyba, że wrzucimy do tego obsługę wyjątków ;)</p>
<p class="code">Kod:</p><pre><code class="language-javascript">try
{
	Function.prototype.call.apply(Function.prototype.bind, &#91;function() {}&#93;)();
}
catch (e)
{}</code></pre>
<p>Dobra, zwracanie niezaciemnionego kodu jest łatwe - wystarczy zwrócić parametr <code>f</code>. Tyle. Zatem po połączeniu wszystkiego razem, otrzymamy coś takiego:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var obfuscate = (function()
{
	var a = Function.prototype;
	
	try
	{
		a.call.apply(a.bind, &#91;function() {}&#93;)();
	}
	catch (e)
	{
		return function(f)
		{
			return f;
		};
	}

	return function(f)
	{
		return a.call.apply(a.bind, &#91;f&#93;);
	};
}());</code></pre>
<ul>
<li> najpierw przypisujemy sobie <code>Function.prototype</code> do zmiennej <code>a</code> (żeby się później nie napisać i oszczędzić te parę bajtów ;))
</li><li> sprawdzamy czy obfuskacja wgl działa w bloku <code>try</code>/<code>catch</code>. jeśli nie, jak gdyby nigdy nic, zwracamy funkcję zwracającą parametr <code>f</code> (nieźle to brzmi ;))
</li><li> w innych przypadkach po prostu zwracamy funkcję zwracającą zaciemnioną funkcję
</li></ul>
<p>Przykład:</p>
<p class="code">Kod:</p><pre><code class="language-javascript">var f = obfuscate(function(n, r)
{
	return n + ':' + r;
});
console.log(f('r', 't')); //"r:t"
console.log(f); //function () { &#91;native code&#93; }</code></pre>
<p>Demo online nie wstawiam, bo raczej za dynamiczne by nie było, zresztą podgląd na forum spełnia swoje zadanie w tym względzie ;)</p>
<p>Aaaaa, i taka uwaga na koniec: moja funkcja <code>obfuscate</code> bardzo lubi strict mode :D</p>

						</article>
						<section id="komentarze">
							<h2>Komentarze</h2>
							<div id="disqus_thread"></div>
							<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
							<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
						</section>
					</main>

					<nav class="col-md-4 well" data-spy="affix" data-offset-top="60" data-offset-bottom="200">
		<h2 class="sidebar-header">Spis treści</h2>
			<div class="sidebar-inner">
				<ul class="unstyled">
				
				</ul>
			</div>
		</nav>
				</div>
			</div>

			<footer class="site-footer">
				<div class="container-fluid">
					<p>Copyright © by <a href="https://www.comandeer.pl" rel="author">Comandeer</a>.</p>
				</div>
			</footer>

			<script>
			(function()
			{
				try
				{
					var b = document.getElementsByClassName('code');
					
					[].forEach.call(b, function(t)
					{
						var n = t.nextElementSibling;
						
						if(!n || n.tagName.toLowerCase() !== 'pre' || n.scrollHeight<300)
							return false;

						t.innerHTML = t.innerHTML.replace(':', ' <span class="code-switch">[Rozwiń]</span>:');
						t.getElementsByTagName('span')[0].toSwitch = n;
					});

					document.addEventListener('click', function(e)
					{
						if(!e.target || !e.target.classList.contains('code-switch'))
							return true;

						e.preventDefault();
						
						var t = e.target
						,n = t.toSwitch
						,iH = t.innerHTML;
						
						if(!n || n.tagName.toLowerCase() !== 'pre')
							return false;
						
						n.classList.toggle('expanded');
						t.innerHTML = (iH === '[Zwiń]' ? '[Rozwiń]' : '[Zwiń]');
					});

					//defer loading of disqus
					window.disqus_shortname = 'comandeerowa';

					var comments = document.getElementById('komentarze')
					,offset = comments.getBoundingClientRect().top
					,dsq = document.createElement('script');

					dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';

					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				}
				catch(e)
				{
				}
			}());
			</script>
			<script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
			<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
			<script src="/js/prism.js"></script>
		</body>
	</html>
